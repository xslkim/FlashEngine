// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BoxFlashInfo.proto

#ifndef PROTOBUF_BoxFlashInfo_2eproto__INCLUDED
#define PROTOBUF_BoxFlashInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BoxFlashInfo_2eproto();
void protobuf_AssignDesc_BoxFlashInfo_2eproto();
void protobuf_ShutdownFile_BoxFlashInfo_2eproto();

class BoxTrans;
class BoxDomFrame;
class BoxActionInfo;
class BoxFlashInfo;

// ===================================================================

class BoxTrans : public ::google::protobuf::Message {
 public:
  BoxTrans();
  virtual ~BoxTrans();
  
  BoxTrans(const BoxTrans& from);
  
  inline BoxTrans& operator=(const BoxTrans& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxTrans& default_instance();
  
  void Swap(BoxTrans* other);
  
  // implements Message ----------------------------------------------
  
  BoxTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxTrans& from);
  void MergeFrom(const BoxTrans& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float ma = 110;
  inline bool has_ma() const;
  inline void clear_ma();
  static const int kMaFieldNumber = 110;
  inline float ma() const;
  inline void set_ma(float value);
  
  // optional float mb = 120;
  inline bool has_mb() const;
  inline void clear_mb();
  static const int kMbFieldNumber = 120;
  inline float mb() const;
  inline void set_mb(float value);
  
  // optional float mc = 130;
  inline bool has_mc() const;
  inline void clear_mc();
  static const int kMcFieldNumber = 130;
  inline float mc() const;
  inline void set_mc(float value);
  
  // optional float md = 140;
  inline bool has_md() const;
  inline void clear_md();
  static const int kMdFieldNumber = 140;
  inline float md() const;
  inline void set_md(float value);
  
  // optional float mtx = 150;
  inline bool has_mtx() const;
  inline void clear_mtx();
  static const int kMtxFieldNumber = 150;
  inline float mtx() const;
  inline void set_mtx(float value);
  
  // optional float mty = 160;
  inline bool has_mty() const;
  inline void clear_mty();
  static const int kMtyFieldNumber = 160;
  inline float mty() const;
  inline void set_mty(float value);
  
  // @@protoc_insertion_point(class_scope:BoxTrans)
 private:
  inline void set_has_ma();
  inline void clear_has_ma();
  inline void set_has_mb();
  inline void clear_has_mb();
  inline void set_has_mc();
  inline void clear_has_mc();
  inline void set_has_md();
  inline void clear_has_md();
  inline void set_has_mtx();
  inline void clear_has_mtx();
  inline void set_has_mty();
  inline void clear_has_mty();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float ma_;
  float mb_;
  float mc_;
  float md_;
  float mtx_;
  float mty_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_BoxFlashInfo_2eproto();
  friend void protobuf_AssignDesc_BoxFlashInfo_2eproto();
  friend void protobuf_ShutdownFile_BoxFlashInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BoxTrans* default_instance_;
};
// -------------------------------------------------------------------

class BoxDomFrame : public ::google::protobuf::Message {
 public:
  BoxDomFrame();
  virtual ~BoxDomFrame();
  
  BoxDomFrame(const BoxDomFrame& from);
  
  inline BoxDomFrame& operator=(const BoxDomFrame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxDomFrame& default_instance();
  
  void Swap(BoxDomFrame* other);
  
  // implements Message ----------------------------------------------
  
  BoxDomFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxDomFrame& from);
  void MergeFrom(const BoxDomFrame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 startFrame = 10;
  inline bool has_startframe() const;
  inline void clear_startframe();
  static const int kStartFrameFieldNumber = 10;
  inline ::google::protobuf::int32 startframe() const;
  inline void set_startframe(::google::protobuf::int32 value);
  
  // required int32 duration = 20;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 20;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);
  
  // repeated .BoxTrans trans = 30;
  inline int trans_size() const;
  inline void clear_trans();
  static const int kTransFieldNumber = 30;
  inline const ::BoxTrans& trans(int index) const;
  inline ::BoxTrans* mutable_trans(int index);
  inline ::BoxTrans* add_trans();
  inline const ::google::protobuf::RepeatedPtrField< ::BoxTrans >&
      trans() const;
  inline ::google::protobuf::RepeatedPtrField< ::BoxTrans >*
      mutable_trans();
  
  // @@protoc_insertion_point(class_scope:BoxDomFrame)
 private:
  inline void set_has_startframe();
  inline void clear_has_startframe();
  inline void set_has_duration();
  inline void clear_has_duration();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 startframe_;
  ::google::protobuf::int32 duration_;
  ::google::protobuf::RepeatedPtrField< ::BoxTrans > trans_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BoxFlashInfo_2eproto();
  friend void protobuf_AssignDesc_BoxFlashInfo_2eproto();
  friend void protobuf_ShutdownFile_BoxFlashInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BoxDomFrame* default_instance_;
};
// -------------------------------------------------------------------

class BoxActionInfo : public ::google::protobuf::Message {
 public:
  BoxActionInfo();
  virtual ~BoxActionInfo();
  
  BoxActionInfo(const BoxActionInfo& from);
  
  inline BoxActionInfo& operator=(const BoxActionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxActionInfo& default_instance();
  
  void Swap(BoxActionInfo* other);
  
  // implements Message ----------------------------------------------
  
  BoxActionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxActionInfo& from);
  void MergeFrom(const BoxActionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string actionName = 5;
  inline bool has_actionname() const;
  inline void clear_actionname();
  static const int kActionNameFieldNumber = 5;
  inline const ::std::string& actionname() const;
  inline void set_actionname(const ::std::string& value);
  inline void set_actionname(const char* value);
  inline void set_actionname(const char* value, size_t size);
  inline ::std::string* mutable_actionname();
  inline ::std::string* release_actionname();
  
  // required .BoxTrans trans = 30;
  inline bool has_trans() const;
  inline void clear_trans();
  static const int kTransFieldNumber = 30;
  inline const ::BoxTrans& trans() const;
  inline ::BoxTrans* mutable_trans();
  inline ::BoxTrans* release_trans();
  
  // repeated .BoxDomFrame hurtDomFrame = 10;
  inline int hurtdomframe_size() const;
  inline void clear_hurtdomframe();
  static const int kHurtDomFrameFieldNumber = 10;
  inline const ::BoxDomFrame& hurtdomframe(int index) const;
  inline ::BoxDomFrame* mutable_hurtdomframe(int index);
  inline ::BoxDomFrame* add_hurtdomframe();
  inline const ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >&
      hurtdomframe() const;
  inline ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >*
      mutable_hurtdomframe();
  
  // repeated .BoxDomFrame attackDomFrame = 20;
  inline int attackdomframe_size() const;
  inline void clear_attackdomframe();
  static const int kAttackDomFrameFieldNumber = 20;
  inline const ::BoxDomFrame& attackdomframe(int index) const;
  inline ::BoxDomFrame* mutable_attackdomframe(int index);
  inline ::BoxDomFrame* add_attackdomframe();
  inline const ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >&
      attackdomframe() const;
  inline ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >*
      mutable_attackdomframe();
  
  // @@protoc_insertion_point(class_scope:BoxActionInfo)
 private:
  inline void set_has_actionname();
  inline void clear_has_actionname();
  inline void set_has_trans();
  inline void clear_has_trans();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* actionname_;
  ::BoxTrans* trans_;
  ::google::protobuf::RepeatedPtrField< ::BoxDomFrame > hurtdomframe_;
  ::google::protobuf::RepeatedPtrField< ::BoxDomFrame > attackdomframe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_BoxFlashInfo_2eproto();
  friend void protobuf_AssignDesc_BoxFlashInfo_2eproto();
  friend void protobuf_ShutdownFile_BoxFlashInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BoxActionInfo* default_instance_;
};
// -------------------------------------------------------------------

class BoxFlashInfo : public ::google::protobuf::Message {
 public:
  BoxFlashInfo();
  virtual ~BoxFlashInfo();
  
  BoxFlashInfo(const BoxFlashInfo& from);
  
  inline BoxFlashInfo& operator=(const BoxFlashInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxFlashInfo& default_instance();
  
  void Swap(BoxFlashInfo* other);
  
  // implements Message ----------------------------------------------
  
  BoxFlashInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxFlashInfo& from);
  void MergeFrom(const BoxFlashInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string spriteName = 5;
  inline bool has_spritename() const;
  inline void clear_spritename();
  static const int kSpriteNameFieldNumber = 5;
  inline const ::std::string& spritename() const;
  inline void set_spritename(const ::std::string& value);
  inline void set_spritename(const char* value);
  inline void set_spritename(const char* value, size_t size);
  inline ::std::string* mutable_spritename();
  inline ::std::string* release_spritename();
  
  // repeated .BoxActionInfo actionInfo = 10;
  inline int actioninfo_size() const;
  inline void clear_actioninfo();
  static const int kActionInfoFieldNumber = 10;
  inline const ::BoxActionInfo& actioninfo(int index) const;
  inline ::BoxActionInfo* mutable_actioninfo(int index);
  inline ::BoxActionInfo* add_actioninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::BoxActionInfo >&
      actioninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::BoxActionInfo >*
      mutable_actioninfo();
  
  // @@protoc_insertion_point(class_scope:BoxFlashInfo)
 private:
  inline void set_has_spritename();
  inline void clear_has_spritename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* spritename_;
  ::google::protobuf::RepeatedPtrField< ::BoxActionInfo > actioninfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_BoxFlashInfo_2eproto();
  friend void protobuf_AssignDesc_BoxFlashInfo_2eproto();
  friend void protobuf_ShutdownFile_BoxFlashInfo_2eproto();
  
  void InitAsDefaultInstance();
  static BoxFlashInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// BoxTrans

// optional float ma = 110;
inline bool BoxTrans::has_ma() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxTrans::set_has_ma() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxTrans::clear_has_ma() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxTrans::clear_ma() {
  ma_ = 0;
  clear_has_ma();
}
inline float BoxTrans::ma() const {
  return ma_;
}
inline void BoxTrans::set_ma(float value) {
  set_has_ma();
  ma_ = value;
}

// optional float mb = 120;
inline bool BoxTrans::has_mb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxTrans::set_has_mb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxTrans::clear_has_mb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxTrans::clear_mb() {
  mb_ = 0;
  clear_has_mb();
}
inline float BoxTrans::mb() const {
  return mb_;
}
inline void BoxTrans::set_mb(float value) {
  set_has_mb();
  mb_ = value;
}

// optional float mc = 130;
inline bool BoxTrans::has_mc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoxTrans::set_has_mc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoxTrans::clear_has_mc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoxTrans::clear_mc() {
  mc_ = 0;
  clear_has_mc();
}
inline float BoxTrans::mc() const {
  return mc_;
}
inline void BoxTrans::set_mc(float value) {
  set_has_mc();
  mc_ = value;
}

// optional float md = 140;
inline bool BoxTrans::has_md() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoxTrans::set_has_md() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoxTrans::clear_has_md() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoxTrans::clear_md() {
  md_ = 0;
  clear_has_md();
}
inline float BoxTrans::md() const {
  return md_;
}
inline void BoxTrans::set_md(float value) {
  set_has_md();
  md_ = value;
}

// optional float mtx = 150;
inline bool BoxTrans::has_mtx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BoxTrans::set_has_mtx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BoxTrans::clear_has_mtx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BoxTrans::clear_mtx() {
  mtx_ = 0;
  clear_has_mtx();
}
inline float BoxTrans::mtx() const {
  return mtx_;
}
inline void BoxTrans::set_mtx(float value) {
  set_has_mtx();
  mtx_ = value;
}

// optional float mty = 160;
inline bool BoxTrans::has_mty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BoxTrans::set_has_mty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BoxTrans::clear_has_mty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BoxTrans::clear_mty() {
  mty_ = 0;
  clear_has_mty();
}
inline float BoxTrans::mty() const {
  return mty_;
}
inline void BoxTrans::set_mty(float value) {
  set_has_mty();
  mty_ = value;
}

// -------------------------------------------------------------------

// BoxDomFrame

// required int32 startFrame = 10;
inline bool BoxDomFrame::has_startframe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxDomFrame::set_has_startframe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxDomFrame::clear_has_startframe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxDomFrame::clear_startframe() {
  startframe_ = 0;
  clear_has_startframe();
}
inline ::google::protobuf::int32 BoxDomFrame::startframe() const {
  return startframe_;
}
inline void BoxDomFrame::set_startframe(::google::protobuf::int32 value) {
  set_has_startframe();
  startframe_ = value;
}

// required int32 duration = 20;
inline bool BoxDomFrame::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxDomFrame::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxDomFrame::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxDomFrame::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 BoxDomFrame::duration() const {
  return duration_;
}
inline void BoxDomFrame::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// repeated .BoxTrans trans = 30;
inline int BoxDomFrame::trans_size() const {
  return trans_.size();
}
inline void BoxDomFrame::clear_trans() {
  trans_.Clear();
}
inline const ::BoxTrans& BoxDomFrame::trans(int index) const {
  return trans_.Get(index);
}
inline ::BoxTrans* BoxDomFrame::mutable_trans(int index) {
  return trans_.Mutable(index);
}
inline ::BoxTrans* BoxDomFrame::add_trans() {
  return trans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BoxTrans >&
BoxDomFrame::trans() const {
  return trans_;
}
inline ::google::protobuf::RepeatedPtrField< ::BoxTrans >*
BoxDomFrame::mutable_trans() {
  return &trans_;
}

// -------------------------------------------------------------------

// BoxActionInfo

// required string actionName = 5;
inline bool BoxActionInfo::has_actionname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxActionInfo::set_has_actionname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxActionInfo::clear_has_actionname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxActionInfo::clear_actionname() {
  if (actionname_ != &::google::protobuf::internal::kEmptyString) {
    actionname_->clear();
  }
  clear_has_actionname();
}
inline const ::std::string& BoxActionInfo::actionname() const {
  return *actionname_;
}
inline void BoxActionInfo::set_actionname(const ::std::string& value) {
  set_has_actionname();
  if (actionname_ == &::google::protobuf::internal::kEmptyString) {
    actionname_ = new ::std::string;
  }
  actionname_->assign(value);
}
inline void BoxActionInfo::set_actionname(const char* value) {
  set_has_actionname();
  if (actionname_ == &::google::protobuf::internal::kEmptyString) {
    actionname_ = new ::std::string;
  }
  actionname_->assign(value);
}
inline void BoxActionInfo::set_actionname(const char* value, size_t size) {
  set_has_actionname();
  if (actionname_ == &::google::protobuf::internal::kEmptyString) {
    actionname_ = new ::std::string;
  }
  actionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxActionInfo::mutable_actionname() {
  set_has_actionname();
  if (actionname_ == &::google::protobuf::internal::kEmptyString) {
    actionname_ = new ::std::string;
  }
  return actionname_;
}
inline ::std::string* BoxActionInfo::release_actionname() {
  clear_has_actionname();
  if (actionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actionname_;
    actionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .BoxTrans trans = 30;
inline bool BoxActionInfo::has_trans() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxActionInfo::set_has_trans() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxActionInfo::clear_has_trans() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxActionInfo::clear_trans() {
  if (trans_ != NULL) trans_->::BoxTrans::Clear();
  clear_has_trans();
}
inline const ::BoxTrans& BoxActionInfo::trans() const {
  return trans_ != NULL ? *trans_ : *default_instance_->trans_;
}
inline ::BoxTrans* BoxActionInfo::mutable_trans() {
  set_has_trans();
  if (trans_ == NULL) trans_ = new ::BoxTrans;
  return trans_;
}
inline ::BoxTrans* BoxActionInfo::release_trans() {
  clear_has_trans();
  ::BoxTrans* temp = trans_;
  trans_ = NULL;
  return temp;
}

// repeated .BoxDomFrame hurtDomFrame = 10;
inline int BoxActionInfo::hurtdomframe_size() const {
  return hurtdomframe_.size();
}
inline void BoxActionInfo::clear_hurtdomframe() {
  hurtdomframe_.Clear();
}
inline const ::BoxDomFrame& BoxActionInfo::hurtdomframe(int index) const {
  return hurtdomframe_.Get(index);
}
inline ::BoxDomFrame* BoxActionInfo::mutable_hurtdomframe(int index) {
  return hurtdomframe_.Mutable(index);
}
inline ::BoxDomFrame* BoxActionInfo::add_hurtdomframe() {
  return hurtdomframe_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >&
BoxActionInfo::hurtdomframe() const {
  return hurtdomframe_;
}
inline ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >*
BoxActionInfo::mutable_hurtdomframe() {
  return &hurtdomframe_;
}

// repeated .BoxDomFrame attackDomFrame = 20;
inline int BoxActionInfo::attackdomframe_size() const {
  return attackdomframe_.size();
}
inline void BoxActionInfo::clear_attackdomframe() {
  attackdomframe_.Clear();
}
inline const ::BoxDomFrame& BoxActionInfo::attackdomframe(int index) const {
  return attackdomframe_.Get(index);
}
inline ::BoxDomFrame* BoxActionInfo::mutable_attackdomframe(int index) {
  return attackdomframe_.Mutable(index);
}
inline ::BoxDomFrame* BoxActionInfo::add_attackdomframe() {
  return attackdomframe_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >&
BoxActionInfo::attackdomframe() const {
  return attackdomframe_;
}
inline ::google::protobuf::RepeatedPtrField< ::BoxDomFrame >*
BoxActionInfo::mutable_attackdomframe() {
  return &attackdomframe_;
}

// -------------------------------------------------------------------

// BoxFlashInfo

// required string spriteName = 5;
inline bool BoxFlashInfo::has_spritename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxFlashInfo::set_has_spritename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxFlashInfo::clear_has_spritename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxFlashInfo::clear_spritename() {
  if (spritename_ != &::google::protobuf::internal::kEmptyString) {
    spritename_->clear();
  }
  clear_has_spritename();
}
inline const ::std::string& BoxFlashInfo::spritename() const {
  return *spritename_;
}
inline void BoxFlashInfo::set_spritename(const ::std::string& value) {
  set_has_spritename();
  if (spritename_ == &::google::protobuf::internal::kEmptyString) {
    spritename_ = new ::std::string;
  }
  spritename_->assign(value);
}
inline void BoxFlashInfo::set_spritename(const char* value) {
  set_has_spritename();
  if (spritename_ == &::google::protobuf::internal::kEmptyString) {
    spritename_ = new ::std::string;
  }
  spritename_->assign(value);
}
inline void BoxFlashInfo::set_spritename(const char* value, size_t size) {
  set_has_spritename();
  if (spritename_ == &::google::protobuf::internal::kEmptyString) {
    spritename_ = new ::std::string;
  }
  spritename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxFlashInfo::mutable_spritename() {
  set_has_spritename();
  if (spritename_ == &::google::protobuf::internal::kEmptyString) {
    spritename_ = new ::std::string;
  }
  return spritename_;
}
inline ::std::string* BoxFlashInfo::release_spritename() {
  clear_has_spritename();
  if (spritename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spritename_;
    spritename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BoxActionInfo actionInfo = 10;
inline int BoxFlashInfo::actioninfo_size() const {
  return actioninfo_.size();
}
inline void BoxFlashInfo::clear_actioninfo() {
  actioninfo_.Clear();
}
inline const ::BoxActionInfo& BoxFlashInfo::actioninfo(int index) const {
  return actioninfo_.Get(index);
}
inline ::BoxActionInfo* BoxFlashInfo::mutable_actioninfo(int index) {
  return actioninfo_.Mutable(index);
}
inline ::BoxActionInfo* BoxFlashInfo::add_actioninfo() {
  return actioninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BoxActionInfo >&
BoxFlashInfo::actioninfo() const {
  return actioninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::BoxActionInfo >*
BoxFlashInfo::mutable_actioninfo() {
  return &actioninfo_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BoxFlashInfo_2eproto__INCLUDED
